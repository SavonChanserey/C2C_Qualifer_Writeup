#!/usr/bin/env python3
"""
Lucky Slots - Optimized Practical Solver
Uses state space analysis for faster cracking
"""

import requests
import time
import sys
from typing import List, Optional, Tuple


class DotNetRandom:
    """
    Faithful .NET System.Random (Knuth subtractive) implementation
    """
    MSEED = 161803398
    MBIG = 2147483647
    
    def __init__(self, seed: int = None, state: Tuple = None):
        if state:
            self._seed_array, self._inext, self._inextp = state
            return
            
        # Convert seed to int32
        seed = seed & 0xFFFFFFFF
        if seed >= 2**31:
            seed -= 2**32
        
        subtraction = (self.MSEED - abs(seed)) % self.MBIG
        
        self._seed_array = [0] * 56
        self._seed_array[55] = subtraction
        
        mk = 1
        for i in range(1, 55):
            ii = (21 * i) % 55
            self._seed_array[ii] = mk
            mk = (subtraction - mk) % self.MBIG
            subtraction = self._seed_array[ii]
        
        # 4 rounds of "tempering"
        for _ in range(4):
            for i in range(1, 56):
                self._seed_array[i] = (self._seed_array[i] - 
                                      self._seed_array[1 + (i + 30) % 55]) % self.MBIG
        
        self._inext = 0
        self._inextp = 21
    
    def internal_sample(self) -> int:
        """Core RNG step"""
        self._inext = (self._inext + 1) % 56
        if self._inext == 0:
            self._inext = 1
            
        self._inextp = (self._inextp + 1) % 56
        if self._inextp == 0:
            self._inextp = 1
        
        retval = (self._seed_array[self._inext] - 
                 self._seed_array[self._inextp]) % self.MBIG
        
        self._seed_array[self._inext] = retval
        return retval
    
    def next_int(self, min_val: int = 0, max_val: int = None) -> int:
        """Generate random int in [min_val, max_val)"""
        if max_val is None:
            max_val = self.MBIG
        
        range_size = max_val - min_val
        sample = self.internal_sample()
        
        # This is how .NET converts to range
        return int(sample * (1.0 / self.MBIG) * range_size) + min_val
    
    def next_bytes(self, buffer: bytearray):
        """Fill buffer with random bytes"""
        for i in range(len(buffer)):
            buffer[i] = self.internal_sample() % 256
    
    def clone(self):
        """Create a clone with same state"""
        return DotNetRandom(state=(
            self._seed_array.copy(),
            self._inext,
            self._inextp
        ))


def warmup_rng(rng: DotNetRandom):
    """Apply server's warmup sequence"""
    buf = bytearray(64)
    rng.next_bytes(buf)
    rng.next_int(0, 1000000)
    rng.next_int(0, 2147483647)


def generate_tick(rng: DotNetRandom) -> dict:
    """Generate one tick frame matching server logic"""
    # 3 reels
    reel0 = rng.next_int(0, 10)
    reel1 = rng.next_int(0, 10)
    reel2 = rng.next_int(0, 10)
    
    # Jackpot preview
    jackpot = rng.next_int(0, 1000000)
    
    # 16 sample ints
    samples = []
    for _ in range(16):
        samples.append(rng.next_int(0, 2147483647))
    
    # 4 sample bytes
    sample_bytes = bytearray(4)
    rng.next_bytes(sample_bytes)
    
    # Redeem code
    redeem = rng.next_int(0, 10000000)
    
    return {
        'reels': [reel0, reel1, reel2],
        'jackpot': jackpot,
        'samples': samples,
        'bytes': sample_bytes.hex(),
        'redeem': redeem
    }


def check_seed_match(seed: int, target_frame: dict, skip_ticks: int = 0) -> bool:
    """Check if a seed produces the target frame after skip_ticks"""
    try:
        rng = DotNetRandom(seed)
        warmup_rng(rng)
        
        # Skip frames
        for _ in range(skip_ticks):
            generate_tick(rng)
        
        # Generate target
        gen = generate_tick(rng)
        
        # Check match (reels + jackpot + first 4 samples)
        return (gen['reels'] == target_frame['reels'] and
                gen['jackpot'] == target_frame['jackpotPreview'] and
                gen['samples'][:4] == target_frame['sampleInts'][:4])
    except:
        return False


def smart_seed_search(frames: List[dict], max_tries: int = 10_000_000) -> Optional[Tuple[int, int]]:
    """
    Smart seed search using multiple frames for validation
    Returns (seed, tick_offset) if found
    """
    print("[*] Starting smart seed search...")
    print(f"    Using {len(frames)} frames for validation")
    
    first_frame = frames[0]
    
    # Focus on smaller seed space first (common CTF pattern)
    search_ranges = [
        (-1_000_000, 1_000_000),       # ¬±1M
        (-10_000_000, 10_000_000),     # ¬±10M
        (-2**30, 2**30),                # Full range (if needed)
    ]
    
    for range_start, range_end in search_ranges:
        print(f"\n[*] Searching range [{range_start:,}, {range_end:,}]...")
        
        checked = 0
        for seed in range(range_start, range_end):
            checked += 1
            
            if checked % 1_000_000 == 0:
                print(f"    Progress: {checked:,} seeds checked...")
            
            if checked > max_tries:
                break
            
            # Try different tick offsets (we don't know which tick this is)
            for offset in range(min(20, len(frames) + 5)):
                if check_seed_match(seed, first_frame, offset):
                    # Found potential match, verify with more frames
                    print(f"\n[+] Candidate found: seed={seed}, offset={offset}")
                    
                    # Verify with additional frames
                    rng = DotNetRandom(seed)
                    warmup_rng(rng)
                    
                    # Skip to first frame
                    for _ in range(offset):
                        generate_tick(rng)
                    
                    # Verify all frames match
                    all_match = True
                    for i, frame in enumerate(frames):
                        gen = generate_tick(rng)
                        if (gen['reels'] != frame['reels'] or
                            gen['samples'][:8] != frame['sampleInts'][:8]):
                            all_match = False
                            break
                    
                    if all_match:
                        print(f"[+] VERIFIED with {len(frames)} frames!")
                        return (seed, offset)
                    else:
                        print(f"    False positive, continuing search...")
    
    print("[!] Seed not found in search space")
    return None


def exploit(base_url: str):
    """Main exploit flow"""
    print("="*70)
    print("LUCKY SLOTS RNG EXPLOITATION")
    print("="*70)
    
    # Fetch recent frames
    print("\n[1] Fetching frames from server...")
    resp = requests.get(f"{base_url}/api/recent/15")
    frames = resp.json()
    print(f"[+] Got {len(frames)} frames (ticks {frames[0]['tickId']}-{frames[-1]['tickId']})")
    
    # Show first frame details
    print(f"\n[*] First frame (tick {frames[0]['tickId']}):")
    print(f"    Reels: {frames[0]['reels']}")
    print(f"    Jackpot: {frames[0]['jackpotPreview']}")
    print(f"    Samples[0:3]: {frames[0]['sampleInts'][:3]}")
    
    # Find seed
    print("\n[2] Attempting to recover RNG seed...")
    result = smart_seed_search(frames, max_tries=5_000_000)
    
    if not result:
        print("\n[!] Failed to recover seed. Try:")
        print("    - Collecting more frames")
        print("    - Increasing search range")
        print("    - Using more powerful hardware/cloud")
        return False
    
    seed, tick_offset = result
    print(f"\n[+] SUCCESS! Seed = {seed}")
    print(f"[+] First frame is at tick offset {tick_offset}")
    
    # Calculate absolute tick number
    first_tick_id = frames[0]['tickId']
    absolute_offset = first_tick_id - 1  # Ticks are 1-indexed
    
    # Fetch current tick
    print("\n[3] Fetching current tick...")
    resp = requests.get(f"{base_url}/api/frame")
    current = resp.json()
    current_tick = current['tickId']
    print(f"[+] Current tick: {current_tick}")
    
    # Predict next tick's redeem code
    print("\n[4] Predicting next tick's redeem code...")
    
    rng = DotNetRandom(seed)
    warmup_rng(rng)
    
    # Fast-forward to next tick
    for _ in range(current_tick):
        gen = generate_tick(rng)
    
    # Generate next tick
    next_gen = generate_tick(rng)
    next_redeem = next_gen['redeem']
    
    print(f"[+] Tick {current_tick + 1} predicted:")
    print(f"    Reels: {next_gen['reels']}")
    print(f"    Redeem code: {next_redeem}")
    
    # Wait for tick to advance
    print("\n[5] Waiting for next tick (2-3 seconds)...")
    time.sleep(2.5)
    
    # Submit redeem
    print("[6] Submitting redeem code...")
    resp = requests.post(
        f"{base_url}/api/redeem",
        json={
            "tickId": current_tick + 1,
            "code": next_redeem
        }
    )
    
    result = resp.json()
    
    print("\n" + "="*70)
    if result.get('success'):
        print("üéâ SUCCESS! üéâ")
        print("="*70)
        print(f"FLAG: {result['flag']}")
    else:
        print("‚ùå FAILED")
        print("="*70)
        print(f"Error: {result.get('message')}")
        print(f"Response: {result}")
    
    return result.get('success', False)


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python3 exploit.py <base_url>")
        print("Example: python3 exploit.py https://challenges.1pc.tf:44963")
        print("        python3 exploit.py challenges.1pc.tf:44963")
        sys.exit(1)
    
    base_url = sys.argv[1].rstrip('/')
    
    # Add https:// if no scheme provided
    if not base_url.startswith(('http://', 'https://')):
        base_url = 'https://' + base_url
        print(f"[*] Using URL: {base_url}")
    
    try:
        success = exploit(base_url)
        sys.exit(0 if success else 1)
    except KeyboardInterrupt:
        print("\n[!] Interrupted")
        sys.exit(1)
    except Exception as e:
        print(f"\n[!] Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
