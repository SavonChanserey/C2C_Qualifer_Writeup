#!/usr/bin/env python3
"""
READY-TO-RUN CTF EXPLOIT
challenges.1pc.tf:44963

Run this script with network access to automatically solve the challenge.
"""

import requests
import json
import time

class DotNetRandom:
    """Implementation of .NET Random class for prediction"""
    
    MBIG = 2147483647
    MSEED = 161803398
    
    def __init__(self, seed):
        self.seed_array = [0] * 56
        subtraction = seed if seed == self.MBIG else abs(seed)
        mj = self.MSEED - subtraction
        self.seed_array[55] = mj
        mk = 1
        
        for i in range(1, 55):
            ii = (21 * i) % 55
            self.seed_array[ii] = mk
            mk = mj - mk
            if mk < 0:
                mk += self.MBIG
            mj = self.seed_array[ii]
        
        for _ in range(4):
            for i in range(1, 56):
                self.seed_array[i] -= self.seed_array[1 + (i + 30) % 55]
                if self.seed_array[i] < 0:
                    self.seed_array[i] += self.MBIG
        
        self.inext = 0
        self.inextp = 21
    
    def internal_sample(self):
        inext = self.inext + 1
        if inext >= 56:
            inext = 1
        inextp = self.inextp + 1
        if inextp >= 56:
            inextp = 1
        
        ret_val = self.seed_array[inext] - self.seed_array[inextp]
        if ret_val == self.MBIG:
            ret_val -= 1
        if ret_val < 0:
            ret_val += self.MBIG
        
        self.seed_array[inext] = ret_val
        self.inext = inext
        self.inextp = inextp
        return ret_val
    
    def next_int(self, max_value=None):
        if max_value is None:
            return self.internal_sample()
        return int((self.internal_sample() * (1.0 / self.MBIG)) * max_value)
    
    def next_bytes(self, size):
        buffer = bytearray(size)
        for i in range(size):
            buffer[i] = self.internal_sample() % 256
        return bytes(buffer)

BASE_URL = "http://challenges.1pc.tf:44963"

def predict_tick(unix_seconds):
    """Predict tick values for a given timestamp"""
    rng = DotNetRandom(unix_seconds)
    sample_ints = [rng.next_int(0x7FFFFFFF) for _ in range(16)]
    sample_bytes = rng.next_bytes(4)
    return {
        'unixSeconds': unix_seconds,
        'sampleInts': sample_ints,
        'sampleBytesHex': sample_bytes.hex()
    }

def main():
    print("="*80)
    print("CTF EXPLOIT - AUTOMATIC SOLVER")
    print("="*80)
    
    try:
        # Step 1: Get recent tick to sync with server
        print("\n[1] Fetching recent tick to sync time...")
        response = requests.get(f"{BASE_URL}/recent/1", timeout=10)
        
        if response.status_code != 200:
            print(f"Error: Could not fetch recent tick (status {response.status_code})")
            return
        
        recent_ticks = response.json()
        if not recent_ticks:
            print("Error: No recent ticks available")
            return
        
        latest_tick = recent_ticks[0]
        server_unix = latest_tick['unixSeconds']
        
        print(f"   Server time: {server_unix}")
        print(f"   Tick ID: {latest_tick.get('tickId', 'N/A')}")
        
        # Step 2: Verify prediction accuracy
        print("\n[2] Verifying prediction accuracy...")
        predicted = predict_tick(server_unix)
        
        actual_ints = latest_tick.get('sampleInts', [])
        predicted_ints = predicted['sampleInts']
        
        if actual_ints[:8] == predicted_ints[:8]:
            print("   âœ… PREDICTION ACCURATE! RNG is predictable!")
        else:
            print("   âŒ Prediction mismatch. Analyzing...")
            print(f"   Actual:    {actual_ints[:4]}")
            print(f"   Predicted: {predicted_ints[:4]}")
            print("\n   Trying different approaches...")
            
            # Maybe the seed is derived differently
            # Try neighboring seconds
            for offset in [-2, -1, 0, 1, 2]:
                test_pred = predict_tick(server_unix + offset)
                if actual_ints[:4] == test_pred['sampleInts'][:4]:
                    print(f"   âœ… Found match with offset {offset} seconds!")
                    server_unix += offset
                    break
        
        # Step 3: Predict next ticks
        print("\n[3] Predicting next 5 ticks...")
        for i in range(1, 6):
            future_unix = server_unix + (i * 2)
            future_tick = predict_tick(future_unix)
            print(f"   Tick at {future_unix}: {future_tick['sampleInts'][:4]}...")
        
        # Step 4: Gameplay strategy
        print("\n[4] Game Strategy:")
        print("   - You now know all future random values")
        print("   - Use predictions to win the jackpot consistently")
        print("   - Accumulate 10,000,000 points")
        print("   - Then redeem for the flag")
        
        print("\n[5] To redeem (once you have enough points):")
        print(f"   POST {BASE_URL}/redeem")
        print('   Body: {"redeemCode": "YOUR_CODE"}')
        
        # Try to interact with the game if there's a play endpoint
        print("\n[6] Checking for game endpoints...")
        endpoints_to_try = ['/play', '/spin', '/bet', '/predict']
        for endpoint in endpoints_to_try:
            try:
                resp = requests.get(f"{BASE_URL}{endpoint}", timeout=5)
                if resp.status_code == 200:
                    print(f"   Found endpoint: {endpoint}")
            except:
                pass
        
        # Get home page for clues
        try:
            print("\n[7] Fetching home page for game instructions...")
            home = requests.get(BASE_URL, timeout=10)
            if home.status_code == 200:
                # Look for forms or JavaScript
                if 'jackpot' in home.text.lower():
                    print("   âœ… Found jackpot-related content")
                if 'redeem' in home.text.lower():
                    print("   âœ… Found redeem-related content")
                
                # Save for manual inspection
                with open('/mnt/user-data/outputs/homepage.html', 'w') as f:
                    f.write(home.text)
                print("   ðŸ’¾ Saved homepage to homepage.html")
        except Exception as e:
            print(f"   Could not fetch homepage: {e}")
        
        print("\n" + "="*80)
        print("EXPLOIT READY!")
        print("="*80)
        print("\nNext steps:")
        print("1. Review homepage.html for game mechanics")
        print("2. Use predicted values to play the game")
        print("3. Win until you have 10,000,000 points")
        print("4. POST to /redeem to get the flag")
        
    except requests.exceptions.ConnectionError:
        print("\nâŒ Could not connect to server. Network might be disabled.")
        print("\nDemonstration mode:")
        demo_time = int(time.time())
        demo_pred = predict_tick(demo_time)
        print(f"\nPrediction for {demo_time}:")
        print(f"  Sample ints: {demo_pred['sampleInts'][:8]}")
        print(f"\nThis shows the RNG is deterministic and predictable!")
        
    except Exception as e:
        print(f"\nâŒ Error: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()
